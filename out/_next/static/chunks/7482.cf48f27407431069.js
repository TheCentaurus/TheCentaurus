"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7482],{57482:function(t,r,e){e.r(r),e.d(r,{Marketplace:function(){return y}});var a=e(2593),i=e(9279),n=e(2177),s=e(62),o=e(47454),c=e(8455),d=e(25025),p=e(70332),g=e(64146),h=e(19485),l=e(61744),u=e(21046);let f=function(t){return t[t.Direct=0]="Direct",t[t.Auction=1]="Auction",t}({});class w{constructor(t,r){this.contractWrapper=t,this.storage=r}getAddress(){return this.contractWrapper.address}async getListing(t){const r=await this.contractWrapper.read("listings",[t]);if(r.assetContract===i.d)throw new o.bx(this.getAddress(),t.toString());if(r.listingType!==f.Direct)throw new o.by(this.getAddress(),t.toString(),"Auction","Direct");return await this.mapListing(r)}async getActiveOffer(t,r){await this.validateListing(a.O$.from(t)),(0,n.Z)(h.isAddress(r),"Address must be a valid address");const e=await this.contractWrapper.read("offers",[t,await(0,o.cL)(r)]);if(e.offeror!==i.d)return await(0,o.dE)(this.contractWrapper.getProvider(),a.O$.from(t),e)}createListing=(0,o.dx)((async t=>{(0,o.dH)(t);const r=await(0,o.cL)(t.assetContractAddress),e=await(0,o.cL)(t.currencyContractAddress);await(0,o.dI)(this.contractWrapper,this.getAddress(),r,t.tokenId,await this.contractWrapper.getSignerAddress());const i=await(0,o.ba)(this.contractWrapper.getProvider(),t.buyoutPricePerToken,e);let n=Math.floor(t.startTimestamp.getTime()/1e3);const s=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;return n<s&&(n=s),o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:r,tokenId:t.tokenId,buyoutPricePerToken:i,currencyToAccept:(0,o.b9)(e),listingType:f.Direct,quantityToList:t.quantity,reservePricePerToken:i,secondsUntilEndTime:t.listingDurationInSeconds,startTime:a.O$.from(n)}],parse:t=>({id:this.contractWrapper.parseLogs("ListingAdded",t?.logs)[0].args.listingId,receipt:t})})}));createListingsBatch=(0,o.dx)((async t=>{const r=await Promise.all(t.map((async t=>(await this.createListing.prepare(t)).encode())));return o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>this.contractWrapper.parseLogs("ListingAdded",t?.logs).map((r=>({id:r.args.listingId,receipt:t})))})}));makeOffer=(0,o.dx)((async(t,r,e,i,n)=>{if((0,o.b8)(e))throw new Error("You must use the wrapped native token address when making an offer with a native token");const s=await(0,o.ba)(this.contractWrapper.getProvider(),i,e);try{await this.getListing(t)}catch(h){throw console.error("Failed to get listing, err =",h),new Error(`Error getting the listing with id ${t}`)}const c=a.O$.from(r),d=a.O$.from(s).mul(c),p=await this.contractWrapper.getCallOverrides()||{};await(0,o.bd)(this.contractWrapper,d,e,p);let g=u.Bz;return n&&(g=a.O$.from(Math.floor(n.getTime()/1e3))),o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"offer",args:[t,r,e,s,g],overrides:p})}));acceptOffer=(0,o.dx)((async(t,r)=>{await this.validateListing(a.O$.from(t));const e=await(0,o.cL)(r),i=await this.contractWrapper.read("offers",[t,e]);return o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"acceptOffer",args:[t,e,i.currency,i.pricePerToken]})}));buyoutListing=(0,o.dx)((async(t,r,e)=>{const i=await this.validateListing(a.O$.from(t)),{valid:n,error:s}=await this.isStillValidListing(i,r);if(!n)throw new Error(`Listing ${t} is no longer valid. ${s}`);const c=e||await this.contractWrapper.getSignerAddress(),d=a.O$.from(r),p=a.O$.from(i.buyoutPrice).mul(d),g=await this.contractWrapper.getCallOverrides()||{};return await(0,o.bd)(this.contractWrapper,p,i.currencyContractAddress,g),o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"buy",args:[t,c,d,i.currencyContractAddress,p],overrides:g})}));updateListing=(0,o.dx)((async t=>o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t.id,t.quantity,t.buyoutPrice,t.buyoutPrice,await(0,o.cL)(t.currencyContractAddress),t.startTimeInSeconds,t.secondsUntilEnd]})));cancelListing=(0,o.dx)((async t=>o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"cancelDirectListing",args:[t]})));async validateListing(t){try{return await this.getListing(t)}catch(r){throw console.error(`Error getting the listing with id ${t}`),r}}async mapListing(t){return{assetContractAddress:t.assetContract,buyoutPrice:a.O$.from(t.buyoutPricePerToken),currencyContractAddress:t.currency,buyoutCurrencyValuePerToken:await(0,o.bc)(this.contractWrapper.getProvider(),t.currency,t.buyoutPricePerToken),id:t.listingId.toString(),tokenId:t.tokenId,quantity:t.quantity,startTimeInSeconds:t.startTime,asset:await(0,o.dF)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),secondsUntilEnd:t.endTime,sellerAddress:t.tokenOwner,type:f.Direct}}async isStillValidListing(t,r){if(!(await(0,o.dG)(this.contractWrapper.getProvider(),this.getAddress(),t.assetContractAddress,t.tokenId,t.sellerAddress)))return{valid:!1,error:`Token '${t.tokenId}' from contract '${t.assetContractAddress}' is not approved for transfer`};const e=this.contractWrapper.getProvider(),a=new g.CH(t.assetContractAddress,d,e),i=await a.supportsInterface(o.cU),n=await a.supportsInterface(o.cV);if(i){const r=new g.CH(t.assetContractAddress,p,e);let a;try{a=await r.ownerOf(t.tokenId)}catch(s){}const i=a?.toLowerCase()===t.sellerAddress.toLowerCase();return{valid:i,error:i?void 0:`Seller is not the owner of Token '${t.tokenId}' from contract '${t.assetContractAddress} anymore'`}}if(n){const a=new g.CH(t.assetContractAddress,c,e),i=(await a.balanceOf(t.sellerAddress,t.tokenId)).gte(r||t.quantity);return{valid:i,error:i?void 0:`Seller does not have enough balance of Token '${t.tokenId}' from contract '${t.assetContractAddress} to fulfill the listing`}}return{valid:!1,error:"Contract does not implement ERC 1155 or ERC 721."}}}class m{constructor(t,r){this.contractWrapper=t,this.storage=r,this.encoder=new o.ag(t)}getAddress(){return this.contractWrapper.address}async getListing(t){const r=await this.contractWrapper.read("listings",[t]);if(r.listingId.toString()!==t.toString())throw new o.bx(this.getAddress(),t.toString());if(r.listingType!==f.Auction)throw new o.by(this.getAddress(),t.toString(),"Direct","Auction");return await this.mapListing(r)}async getWinningBid(t){await this.validateListing(a.O$.from(t));const r=await this.contractWrapper.read("winningBid",[t]);if(r.offeror!==i.d)return await(0,o.dE)(this.contractWrapper.getProvider(),a.O$.from(t),r)}async getWinner(t){const r=await this.validateListing(a.O$.from(t)),e=await this.contractWrapper.read("winningBid",[t]),n=a.O$.from(Math.floor(Date.now()/1e3)),s=a.O$.from(r.endTimeInEpochSeconds);if(n.gt(s)&&e.offeror!==i.d)return e.offeror;const c=new o.aR(this.contractWrapper),d=(await c.getEvents("AuctionClosed")).find((r=>r.data.listingId.eq(a.O$.from(t))));if(!d)throw new Error(`Could not find auction with listingId ${t} in closed auctions`);return d.data.winningBidder}createListing=(0,o.dx)((async t=>{(0,o.dH)(t);const r=await(0,o.cL)(t.assetContractAddress),e=await(0,o.cL)(t.currencyContractAddress);await(0,o.dI)(this.contractWrapper,this.getAddress(),r,t.tokenId,await this.contractWrapper.getSignerAddress());const i=await(0,o.ba)(this.contractWrapper.getProvider(),t.buyoutPricePerToken,e),n=await(0,o.ba)(this.contractWrapper.getProvider(),t.reservePricePerToken,e);let s=Math.floor(t.startTimestamp.getTime()/1e3);const c=(await this.contractWrapper.getProvider().getBlock("latest")).timestamp;return s<c&&(s=c),o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"createListing",args:[{assetContract:r,tokenId:t.tokenId,buyoutPricePerToken:i,currencyToAccept:(0,o.b9)(e),listingType:f.Auction,quantityToList:t.quantity,reservePricePerToken:n,secondsUntilEndTime:t.listingDurationInSeconds,startTime:a.O$.from(s)}],parse:t=>({id:this.contractWrapper.parseLogs("ListingAdded",t?.logs)[0].args.listingId,receipt:t})})}));createListingsBatch=(0,o.dx)((async t=>{const r=await Promise.all(t.map((async t=>(await this.createListing.prepare(t)).encode())));return o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r],parse:t=>this.contractWrapper.parseLogs("ListingAdded",t?.logs).map((r=>({id:r.args.listingId,receipt:t})))})}));buyoutListing=(0,o.dx)((async t=>{const r=await this.validateListing(a.O$.from(t)),e=await(0,o.bb)(this.contractWrapper.getProvider(),r.currencyContractAddress);return this.makeBid.prepare(t,l.formatUnits(r.buyoutPrice,e.decimals))}));makeBid=(0,o.dx)((async(t,r)=>{const e=await this.validateListing(a.O$.from(t)),i=await(0,o.ba)(this.contractWrapper.getProvider(),r,e.currencyContractAddress);if(i.eq(a.O$.from(0)))throw new Error("Cannot make a bid with 0 value");const s=await this.contractWrapper.read("bidBufferBps",[]),c=await this.getWinningBid(t);if(c){const t=(0,o.dJ)(c.pricePerToken,i,s);(0,n.Z)(t,"Bid price is too low based on the current winning bid and the bid buffer")}else{const t=i,r=a.O$.from(e.reservePrice);(0,n.Z)(t.gte(r),"Bid price is too low based on reserve price")}const d=a.O$.from(e.quantity),p=i.mul(d),g=await this.contractWrapper.getCallOverrides()||{};return await(0,o.bd)(this.contractWrapper,p,e.currencyContractAddress,g),o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"offer",args:[t,e.quantity,e.currencyContractAddress,i,u.Bz],overrides:g})}));cancelListing=(0,o.dx)((async t=>{const r=await this.validateListing(a.O$.from(t)),e=a.O$.from(Math.floor(Date.now()/1e3)),n=a.O$.from(r.startTimeInEpochSeconds),s=await this.contractWrapper.read("winningBid",[t]);if(e.gt(n)&&s.offeror!==i.d)throw new o.bv(t.toString());return o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"closeAuction",args:[a.O$.from(t),await this.contractWrapper.getSignerAddress()]})}));closeListing=(0,o.dx)((async(t,r)=>{r||(r=await this.contractWrapper.getSignerAddress());const e=await this.validateListing(a.O$.from(t));try{return o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"closeAuction",args:[a.O$.from(t),r]})}catch(i){throw i.message.includes("cannot close auction before it has ended")?new o.bB(t.toString(),e.endTimeInEpochSeconds.toString()):i}}));executeSale=(0,o.dx)((async t=>{const r=await this.validateListing(a.O$.from(t));try{const e=await this.getWinningBid(t);(0,n.Z)(e,"No winning bid found");const a=this.encoder.encode("closeAuction",[t,r.sellerAddress]),i=this.encoder.encode("closeAuction",[t,e.buyerAddress]);return o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[a,i]})}catch(e){throw e.message.includes("cannot close auction before it has ended")?new o.bB(t.toString(),r.endTimeInEpochSeconds.toString()):e}}));updateListing=(0,o.dx)((async t=>o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"updateListing",args:[t.id,t.quantity,t.reservePrice,t.buyoutPrice,t.currencyContractAddress,t.startTimeInEpochSeconds,t.endTimeInEpochSeconds]})));async getBidBufferBps(){return this.contractWrapper.read("bidBufferBps",[])}async getMinimumNextBid(t){const[r,e,i]=await Promise.all([this.getBidBufferBps(),this.getWinningBid(t),await this.validateListing(a.O$.from(t))]),n=e?e.currencyValue.value:i.reservePrice,s=n.add(n.mul(r).div(1e4));return(0,o.bc)(this.contractWrapper.getProvider(),i.currencyContractAddress,s)}async validateListing(t){try{return await this.getListing(t)}catch(r){throw console.error(`Error getting the listing with id ${t}`),r}}async mapListing(t){return{assetContractAddress:t.assetContract,buyoutPrice:a.O$.from(t.buyoutPricePerToken),currencyContractAddress:t.currency,buyoutCurrencyValuePerToken:await(0,o.bc)(this.contractWrapper.getProvider(),t.currency,t.buyoutPricePerToken),id:t.listingId.toString(),tokenId:t.tokenId,quantity:t.quantity,startTimeInEpochSeconds:t.startTime,asset:await(0,o.dF)(t.assetContract,this.contractWrapper.getProvider(),t.tokenId,this.storage),reservePriceCurrencyValuePerToken:await(0,o.bc)(this.contractWrapper.getProvider(),t.currency,t.reservePricePerToken),reservePrice:a.O$.from(t.reservePricePerToken),endTimeInEpochSeconds:t.endTime,sellerAddress:t.tokenOwner,type:f.Auction}}}e(13550),e(64063),e(2162),e(77191),e(54098),e(71770);class y{static contractRoles=o.dN;get chainId(){return this._chainId}constructor(t,r,e){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i=arguments.length>4?arguments[4]:void 0,n=arguments.length>5?arguments[5]:void 0,s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:new o.dw(t,r,i,a,e);this._chainId=n,this.abi=o.e.parse(i||[]),this.contractWrapper=s,this.storage=e,this.metadata=new o.ah(this.contractWrapper,o.dO,this.storage),this.app=new o.b0(this.contractWrapper,this.metadata,this.storage),this.roles=new o.ai(this.contractWrapper,y.contractRoles),this.encoder=new o.ag(this.contractWrapper),this.estimator=new o.aQ(this.contractWrapper),this.direct=new w(this.contractWrapper,this.storage),this.auction=new m(this.contractWrapper,this.storage),this.events=new o.aR(this.contractWrapper),this.platformFees=new o.aT(this.contractWrapper),this.interceptor=new o.aS(this.contractWrapper)}onNetworkUpdated(t){this.contractWrapper.updateSignerOrProvider(t)}getAddress(){return this.contractWrapper.address}async getListing(t){const r=await this.contractWrapper.read("listings",[t]);if(r.assetContract===i.d)throw new o.bx(this.getAddress(),t.toString());switch(r.listingType){case f.Auction:return await this.auction.mapListing(r);case f.Direct:return await this.direct.mapListing(r);default:throw new Error(`Unknown listing type: ${r.listingType}`)}}async getActiveListings(t){const r=await this.getAllListingsNoFilter(!0),e=this.applyFilter(r,t),i=a.O$.from(Math.floor(Date.now()/1e3));return e.filter((t=>t.type===f.Auction&&a.O$.from(t.endTimeInEpochSeconds).gt(i)&&a.O$.from(t.startTimeInEpochSeconds).lte(i)||t.type===f.Direct&&a.O$.from(t.quantity).gt(0)))}async getAllListings(t){const r=await this.getAllListingsNoFilter(!1);return this.applyFilter(r,t)}getAll=this.getAllListings;async getTotalCount(){return await this.contractWrapper.read("totalListings",[])}async isRestrictedToListerRoleOnly(){return!(await this.contractWrapper.read("hasRole",[(0,o.bI)("lister"),i.d]))}async getBidBufferBps(){return this.contractWrapper.read("bidBufferBps",[])}async getTimeBufferInSeconds(){return this.contractWrapper.read("timeBuffer",[])}async getOffers(t){const r=await this.events.getEvents("NewOffer",{order:"desc",filters:{listingId:t}});return await Promise.all(r.map((async r=>await(0,o.dE)(this.contractWrapper.getProvider(),a.O$.from(t),{quantityWanted:r.data.quantityWanted,pricePerToken:r.data.quantityWanted.gt(0)?r.data.totalOfferAmount.div(r.data.quantityWanted):r.data.totalOfferAmount,currency:r.data.currency,offeror:r.data.offeror}))))}buyoutListing=(0,o.dx)((async(t,r,e)=>{const a=await this.contractWrapper.read("listings",[t]);if(a.listingId.toString()!==t.toString())throw new o.bx(this.getAddress(),t.toString());switch(a.listingType){case f.Direct:return(0,n.Z)(void 0!==r,"quantityDesired is required when buying out a direct listing"),await this.direct.buyoutListing.prepare(t,r,e);case f.Auction:return await this.auction.buyoutListing.prepare(t);default:throw Error(`Unknown listing type: ${a.listingType}`)}}));makeOffer=(0,o.dx)((async(t,r,e)=>{const a=await this.contractWrapper.read("listings",[t]);if(a.listingId.toString()!==t.toString())throw new o.bx(this.getAddress(),t.toString());const i=await this.contractWrapper.getChainID();switch(a.listingType){case f.Direct:return(0,n.Z)(e,"quantity is required when making an offer on a direct listing"),await this.direct.makeOffer.prepare(t,e,(0,o.b8)(a.currency)?o.cX[i].wrapped.address:a.currency,r);case f.Auction:return await this.auction.makeBid.prepare(t,r);default:throw Error(`Unknown listing type: ${a.listingType}`)}}));setBidBufferBps=(0,o.dx)((async t=>{await this.roles.verify(["admin"],await this.contractWrapper.getSignerAddress());const r=await this.getTimeBufferInSeconds();return o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAuctionBuffers",args:[r,a.O$.from(t)]})}));setTimeBufferInSeconds=(0,o.dx)((async t=>{await this.roles.verify(["admin"],await this.contractWrapper.getSignerAddress());const r=await this.getBidBufferBps();return o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"setAuctionBuffers",args:[a.O$.from(t),r]})}));allowListingFromSpecificAssetOnly=(0,o.dx)((async t=>{const r=[];return(await this.roles.get("asset")).includes(i.d)&&r.push(this.encoder.encode("revokeRole",[(0,o.bI)("asset"),i.d])),r.push(this.encoder.encode("grantRole",[(0,o.bI)("asset"),t])),o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[r]})}));allowListingFromAnyAsset=(0,o.dx)((async()=>{const t=[],r=await this.roles.get("asset");for(const e in r)t.push(this.encoder.encode("revokeRole",[(0,o.bI)("asset"),e]));return t.push(this.encoder.encode("grantRole",[(0,o.bI)("asset"),i.d])),o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:"multicall",args:[t]})}));async getAllListingsNoFilter(t){return(await Promise.all(Array.from(Array((await this.contractWrapper.read("totalListings",[])).toNumber()).keys()).map((async r=>{let e;try{e=await this.getListing(r)}catch(a){return a instanceof o.bx?void 0:void console.warn(`Failed to get listing ${r}' - skipping. Try 'marketplace.getListing(${r})' to get the underlying error.`)}if(e.type===f.Auction)return e;if(t){const{valid:t}=await this.direct.isStillValidListing(e);if(!t)return}return e})))).filter((t=>void 0!==t))}applyFilter(t,r){let e=[...t];const i=a.O$.from(r?.start||0).toNumber(),n=a.O$.from(r?.count||s.D).toNumber();return r&&(r.seller&&(e=e.filter((t=>t.sellerAddress.toString().toLowerCase()===r?.seller?.toString().toLowerCase()))),r.tokenContract&&(e=e.filter((t=>t.assetContractAddress.toString().toLowerCase()===r?.tokenContract?.toString().toLowerCase()))),void 0!==r.tokenId&&(e=e.filter((t=>t.tokenId.toString()===r?.tokenId?.toString()))),e=e.filter(((t,r)=>r>=i)),e=e.slice(0,n)),e}async prepare(t,r,e){return o.aW.fromContractWrapper({contractWrapper:this.contractWrapper,method:t,args:r,overrides:e})}async call(t,r,e){return this.contractWrapper.call(t,r,e)}}}}]);